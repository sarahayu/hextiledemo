import{_ as f}from"./settings-3f87ae0a.js";import{g as V}from"./SolidHexTileLayer-72de8124.js";function E(e,t){if(!e)throw new Error(t||"loader assertion failed.")}class F{constructor(t,i){f(this,"fields",void 0),f(this,"metadata",void 0),E(Array.isArray(t)),y(t),this.fields=t,this.metadata=i||new Map}compareTo(t){if(this.metadata!==t.metadata||this.fields.length!==t.fields.length)return!1;for(let i=0;i<this.fields.length;++i)if(!this.fields[i].compareTo(t.fields[i]))return!1;return!0}select(){const t=Object.create(null);for(var i=arguments.length,s=new Array(i),n=0;n<i;n++)s[n]=arguments[n];for(const o of s)t[o]=!0;const r=this.fields.filter(o=>t[o.name]);return new F(r,this.metadata)}selectAt(){for(var t=arguments.length,i=new Array(t),s=0;s<t;s++)i[s]=arguments[s];const n=i.map(r=>this.fields[r]).filter(Boolean);return new F(n,this.metadata)}assign(t){let i,s=this.metadata;if(t instanceof F){const o=t;i=o.fields,s=O(O(new Map,this.metadata),o.metadata)}else i=t;const n=Object.create(null);for(const o of this.fields)n[o.name]=o;for(const o of i)n[o.name]=o;const r=Object.values(n);return new F(r,s)}}function y(e){const t={};for(const i of e)t[i.name]&&console.warn("Schema: duplicated field name",i.name,i),t[i.name]=!0}function O(e,t){return new Map([...e||new Map,...t||new Map])}class j{constructor(t,i){let s=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1,n=arguments.length>3&&arguments[3]!==void 0?arguments[3]:new Map;f(this,"name",void 0),f(this,"type",void 0),f(this,"nullable",void 0),f(this,"metadata",void 0),this.name=t,this.type=i,this.nullable=s,this.metadata=n}get typeId(){return this.type&&this.type.typeId}clone(){return new j(this.name,this.type,this.nullable,this.metadata)}compareTo(t){return this.name===t.name&&this.type===t.type&&this.nullable===t.nullable&&this.metadata===t.metadata}toString(){return"".concat(this.type).concat(this.nullable?", nullable":"").concat(this.metadata?", metadata: ".concat(this.metadata):"")}}let u=function(e){return e[e.NONE=0]="NONE",e[e.Null=1]="Null",e[e.Int=2]="Int",e[e.Float=3]="Float",e[e.Binary=4]="Binary",e[e.Utf8=5]="Utf8",e[e.Bool=6]="Bool",e[e.Decimal=7]="Decimal",e[e.Date=8]="Date",e[e.Time=9]="Time",e[e.Timestamp=10]="Timestamp",e[e.Interval=11]="Interval",e[e.List=12]="List",e[e.Struct=13]="Struct",e[e.Union=14]="Union",e[e.FixedSizeBinary=15]="FixedSizeBinary",e[e.FixedSizeList=16]="FixedSizeList",e[e.Map=17]="Map",e[e.Dictionary=-1]="Dictionary",e[e.Int8=-2]="Int8",e[e.Int16=-3]="Int16",e[e.Int32=-4]="Int32",e[e.Int64=-5]="Int64",e[e.Uint8=-6]="Uint8",e[e.Uint16=-7]="Uint16",e[e.Uint32=-8]="Uint32",e[e.Uint64=-9]="Uint64",e[e.Float16=-10]="Float16",e[e.Float32=-11]="Float32",e[e.Float64=-12]="Float64",e[e.DateDay=-13]="DateDay",e[e.DateMillisecond=-14]="DateMillisecond",e[e.TimestampSecond=-15]="TimestampSecond",e[e.TimestampMillisecond=-16]="TimestampMillisecond",e[e.TimestampMicrosecond=-17]="TimestampMicrosecond",e[e.TimestampNanosecond=-18]="TimestampNanosecond",e[e.TimeSecond=-19]="TimeSecond",e[e.TimeMillisecond=-20]="TimeMillisecond",e[e.TimeMicrosecond=-21]="TimeMicrosecond",e[e.TimeNanosecond=-22]="TimeNanosecond",e[e.DenseUnion=-23]="DenseUnion",e[e.SparseUnion=-24]="SparseUnion",e[e.IntervalDayTime=-25]="IntervalDayTime",e[e.IntervalYearMonth=-26]="IntervalYearMonth",e}({}),U,A,z;class L{static isNull(t){return t&&t.typeId===u.Null}static isInt(t){return t&&t.typeId===u.Int}static isFloat(t){return t&&t.typeId===u.Float}static isBinary(t){return t&&t.typeId===u.Binary}static isUtf8(t){return t&&t.typeId===u.Utf8}static isBool(t){return t&&t.typeId===u.Bool}static isDecimal(t){return t&&t.typeId===u.Decimal}static isDate(t){return t&&t.typeId===u.Date}static isTime(t){return t&&t.typeId===u.Time}static isTimestamp(t){return t&&t.typeId===u.Timestamp}static isInterval(t){return t&&t.typeId===u.Interval}static isList(t){return t&&t.typeId===u.List}static isStruct(t){return t&&t.typeId===u.Struct}static isUnion(t){return t&&t.typeId===u.Union}static isFixedSizeBinary(t){return t&&t.typeId===u.FixedSizeBinary}static isFixedSizeList(t){return t&&t.typeId===u.FixedSizeList}static isMap(t){return t&&t.typeId===u.Map}static isDictionary(t){return t&&t.typeId===u.Dictionary}get typeId(){return u.NONE}compareTo(t){return this===t}}U=Symbol.toStringTag;class x extends L{constructor(t,i){super(),f(this,"isSigned",void 0),f(this,"bitWidth",void 0),this.isSigned=t,this.bitWidth=i}get typeId(){return u.Int}get[U](){return"Int"}toString(){return"".concat(this.isSigned?"I":"Ui","nt").concat(this.bitWidth)}}class C extends x{constructor(){super(!0,8)}}class R extends x{constructor(){super(!0,16)}}class P extends x{constructor(){super(!0,32)}}class J extends x{constructor(){super(!1,8)}}class _ extends x{constructor(){super(!1,16)}}class G extends x{constructor(){super(!1,32)}}const N={HALF:16,SINGLE:32,DOUBLE:64};A=Symbol.toStringTag;class B extends L{constructor(t){super(),f(this,"precision",void 0),this.precision=t}get typeId(){return u.Float}get[A](){return"Float"}toString(){return"Float".concat(this.precision)}}class k extends B{constructor(){super(N.SINGLE)}}class $ extends B{constructor(){super(N.DOUBLE)}}z=Symbol.toStringTag;class W extends L{constructor(t,i){super(),f(this,"listSize",void 0),f(this,"children",void 0),this.listSize=t,this.children=[i]}get typeId(){return u.FixedSizeList}get valueType(){return this.children[0].type}get valueField(){return this.children[0]}get[z](){return"FixedSizeList"}toString(){return"FixedSizeList[".concat(this.listSize,"]<").concat(this.valueType,">")}}function X(e){switch(e.constructor){case Int8Array:return new C;case Uint8Array:return new J;case Int16Array:return new R;case Uint16Array:return new _;case Int32Array:return new P;case Uint32Array:return new G;case Float32Array:return new k;case Float64Array:return new $;default:throw new Error("array type not supported")}}const Y=/^[og]\s*(.+)?/,H=/^mtllib /,q=/^usemtl /;class M{constructor(t){let{index:i,name:s="",mtllib:n,smooth:r,groupStart:o}=t;this.index=i,this.name=s,this.mtllib=n,this.smooth=r,this.groupStart=o,this.groupEnd=-1,this.groupCount=-1,this.inherited=!1}clone(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:this.index;return new M({index:t,name:this.name,mtllib:this.mtllib,smooth:this.smooth,groupStart:0})}}class K{constructor(){let t=arguments.length>0&&arguments[0]!==void 0?arguments[0]:"";this.name=t,this.geometry={vertices:[],normals:[],colors:[],uvs:[]},this.materials=[],this.smooth=!0,this.fromDeclaration=null}startMaterial(t,i){const s=this._finalize(!1);s&&(s.inherited||s.groupCount<=0)&&this.materials.splice(s.index,1);const n=new M({index:this.materials.length,name:t,mtllib:Array.isArray(i)&&i.length>0?i[i.length-1]:"",smooth:s!==void 0?s.smooth:this.smooth,groupStart:s!==void 0?s.groupEnd:0});return this.materials.push(n),n}currentMaterial(){if(this.materials.length>0)return this.materials[this.materials.length-1]}_finalize(t){const i=this.currentMaterial();if(i&&i.groupEnd===-1&&(i.groupEnd=this.geometry.vertices.length/3,i.groupCount=i.groupEnd-i.groupStart,i.inherited=!1),t&&this.materials.length>1)for(let s=this.materials.length-1;s>=0;s--)this.materials[s].groupCount<=0&&this.materials.splice(s,1);return t&&this.materials.length===0&&this.materials.push({name:"",smooth:this.smooth}),i}}class Q{constructor(){this.objects=[],this.object=null,this.vertices=[],this.normals=[],this.colors=[],this.uvs=[],this.materialLibraries=[],this.startObject("",!1)}startObject(t){let i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;if(this.object&&!this.object.fromDeclaration){this.object.name=t,this.object.fromDeclaration=i;return}const s=this.object&&typeof this.object.currentMaterial=="function"?this.object.currentMaterial():void 0;if(this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0),this.object=new K(t),this.object.fromDeclaration=i,s&&s.name&&typeof s.clone=="function"){const n=s.clone(0);n.inherited=!0,this.object.materials.push(n)}this.objects.push(this.object)}finalize(){this.object&&typeof this.object._finalize=="function"&&this.object._finalize(!0)}parseVertexIndex(t,i){const s=parseInt(t);return(s>=0?s-1:s+i/3)*3}parseNormalIndex(t,i){const s=parseInt(t);return(s>=0?s-1:s+i/3)*3}parseUVIndex(t,i){const s=parseInt(t);return(s>=0?s-1:s+i/2)*2}addVertex(t,i,s){const n=this.vertices,r=this.object.geometry.vertices;r.push(n[t+0],n[t+1],n[t+2]),r.push(n[i+0],n[i+1],n[i+2]),r.push(n[s+0],n[s+1],n[s+2])}addVertexPoint(t){const i=this.vertices;this.object.geometry.vertices.push(i[t+0],i[t+1],i[t+2])}addVertexLine(t){const i=this.vertices;this.object.geometry.vertices.push(i[t+0],i[t+1],i[t+2])}addNormal(t,i,s){const n=this.normals,r=this.object.geometry.normals;r.push(n[t+0],n[t+1],n[t+2]),r.push(n[i+0],n[i+1],n[i+2]),r.push(n[s+0],n[s+1],n[s+2])}addColor(t,i,s){const n=this.colors,r=this.object.geometry.colors;r.push(n[t+0],n[t+1],n[t+2]),r.push(n[i+0],n[i+1],n[i+2]),r.push(n[s+0],n[s+1],n[s+2])}addUV(t,i,s){const n=this.uvs,r=this.object.geometry.uvs;r.push(n[t+0],n[t+1]),r.push(n[i+0],n[i+1]),r.push(n[s+0],n[s+1])}addUVLine(t){const i=this.uvs;this.object.geometry.uvs.push(i[t+0],i[t+1])}addFace(t,i,s,n,r,o,h,p,v){const m=this.vertices.length;let l=this.parseVertexIndex(t,m),a=this.parseVertexIndex(i,m),c=this.parseVertexIndex(s,m);if(this.addVertex(l,a,c),n!==void 0&&n!==""){const d=this.uvs.length;l=this.parseUVIndex(n,d),a=this.parseUVIndex(r,d),c=this.parseUVIndex(o,d),this.addUV(l,a,c)}if(h!==void 0&&h!==""){const d=this.normals.length;l=this.parseNormalIndex(h,d),a=h===p?l:this.parseNormalIndex(p,d),c=h===v?l:this.parseNormalIndex(v,d),this.addNormal(l,a,c)}this.colors.length>0&&this.addColor(l,a,c)}addPointGeometry(t){this.object.geometry.type="Points";const i=this.vertices.length;for(const s of t)this.addVertexPoint(this.parseVertexIndex(s,i))}addLineGeometry(t,i){this.object.geometry.type="Line";const s=this.vertices.length,n=this.uvs.length;for(const r of t)this.addVertexLine(this.parseVertexIndex(r,s));for(const r of i)this.addUVLine(this.parseUVIndex(r,n))}}function Z(e){const t=new Q;e.indexOf(`\r
`)!==-1&&(e=e.replace(/\r\n/g,`
`)),e.indexOf(`\\
`)!==-1&&(e=e.replace(/\\\n/g,""));const i=e.split(`
`);let s="",n="",r=0,o=[];const h=typeof"".trimLeft=="function";for(let m=0,l=i.length;m<l;m++)if(s=i[m],s=h?s.trimLeft():s.trim(),r=s.length,r!==0&&(n=s.charAt(0),n!=="#"))if(n==="v"){const a=s.split(/\s+/);switch(a[0]){case"v":t.vertices.push(parseFloat(a[1]),parseFloat(a[2]),parseFloat(a[3])),a.length>=7&&t.colors.push(parseFloat(a[4]),parseFloat(a[5]),parseFloat(a[6]));break;case"vn":t.normals.push(parseFloat(a[1]),parseFloat(a[2]),parseFloat(a[3]));break;case"vt":t.uvs.push(parseFloat(a[1]),parseFloat(a[2]));break}}else if(n==="f"){const c=s.substr(1).trim().split(/\s+/),d=[];for(let g=0,b=c.length;g<b;g++){const S=c[g];if(S.length>0){const w=S.split("/");d.push(w)}}const I=d[0];for(let g=1,b=d.length-1;g<b;g++){const S=d[g],w=d[g+1];t.addFace(I[0],S[0],w[0],I[1],S[1],w[1],I[2],S[2],w[2])}}else if(n==="l"){const a=s.substring(1).trim().split(" ");let c;const d=[];if(s.indexOf("/")===-1)c=a;else{c=[];for(let I=0,g=a.length;I<g;I++){const b=a[I].split("/");b[0]!==""&&c.push(b[0]),b[1]!==""&&d.push(b[1])}}t.addLineGeometry(c,d)}else if(n==="p"){const c=s.substr(1).trim().split(" ");t.addPointGeometry(c)}else if((o=Y.exec(s))!==null){const a=(" "+o[0].substr(1).trim()).substr(1);t.startObject(a)}else if(q.test(s))t.object.startMaterial(s.substring(7).trim(),t.materialLibraries);else if(H.test(s))t.materialLibraries.push(s.substring(7).trim());else if(n==="s"){if(o=s.split(" "),o.length>1){const c=o[1].trim().toLowerCase();t.object.smooth=c!=="0"&&c!=="off"}else t.object.smooth=!0;const a=t.object.currentMaterial();a&&(a.smooth=t.object.smooth)}else{if(s==="\0")continue;throw new Error('Unexpected line: "'.concat(s,'"'))}t.finalize();const p=[],v=[];for(const m of t.objects){const{geometry:l}=m;if(l.vertices.length===0)continue;const a={header:{vertexCount:l.vertices.length/3},attributes:{}};switch(l.type){case"Points":a.mode=0;break;case"Line":a.mode=1;break;default:a.mode=4;break}a.attributes.POSITION={value:new Float32Array(l.vertices),size:3},l.normals.length>0&&(a.attributes.NORMAL={value:new Float32Array(l.normals),size:3}),l.colors.length>0&&(a.attributes.COLOR_0={value:new Float32Array(l.colors),size:3}),l.uvs.length>0&&(a.attributes.TEXCOORD_0={value:new Float32Array(l.uvs),size:2}),a.materials=[];for(const c of m.materials){const d={name:c.name,flatShading:!c.smooth};a.materials.push(d),v.push(d)}a.name=m.name,p.push(a)}return{meshes:p,materials:v}}function T(e){let t=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},i;for(const n in t)i=i||new Map,n!=="value"&&i.set(n,JSON.stringify(t[n]));const s=[];for(const n in e){const r=e[n],o=tt(n,r);s.push(o)}return new F(s,i)}function tt(e,t){const i=new Map;for(const r in t)r!=="value"&&i.set(r,JSON.stringify(t[r]));const s=X(t.value);return!("size"in t)||t.size===1?new j(e,s,!1,i):new j(e,new W(t.size,new j("value",s)),!1,i)}function D(e,t){const{meshes:i}=Z(e),s=i.reduce((h,p)=>h+p.header.vertexCount,0),n=et(i,s),r={vertexCount:s,boundingBox:V(n)},o=T(n,{mode:4,boundingBox:r.boundingBox});return{loaderData:{header:{}},schema:o,header:r,mode:4,attributes:n}}function et(e,t){const i=new Float32Array(t*3);let s,n,r,o=0;for(const p of e){const{POSITION:v,NORMAL:m,COLOR_0:l,TEXCOORD_0:a}=p.attributes;i.set(v.value,o*3),m&&(s=s||new Float32Array(t*3),s.set(m.value,o*3)),l&&(n=n||new Float32Array(t*3),n.set(l.value,o*3)),a&&(r=r||new Float32Array(t*2),r.set(a.value,o*2)),o+=v.value.length/3}const h={};return h.POSITION={value:i,size:3},s&&(h.NORMAL={value:s,size:3}),n&&(h.COLOR_0={value:n,size:3}),r&&(h.TEXCOORD_0={value:r,size:2}),h}const st="3.4.14",it={name:"OBJ",id:"obj",module:"obj",version:st,worker:!0,extensions:["obj"],mimeTypes:["text/plain"],testText:nt,options:{obj:{}}};function nt(e){return e[0]==="v"}const ot={...it,parse:async(e,t)=>D(new TextDecoder().decode(e)),parseTextSync:(e,t)=>D(e)};export{ot as O};
